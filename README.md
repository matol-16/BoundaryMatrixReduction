# BoundaryMatrixReduction

This repo is dedicated to a projet for the module *Topological Data Analysis* taught by Steve Oudot at **Ecole Polytechnique**.


Our code is organized in the following fashion:

First, two main classes, stored in Python files of the same name.

Simplex class

This class stores vertices, dimension, and filtration value for each simplex of a set.
Vertices are stored as a frozenset to allow storing indices of sub-simplices in a dictionary.

SparseBoundaryMatrix class

This is the central class, which stores a matrix as a dictionary of columnâ€“row sets â€” a structure adapted to the reduction algorithm.

After initialization, an instance of SparseBoundaryMatrix can be attributed to a filtration via the method:

SparseBoundaryMatrix.from_simplices()


This method creates the corresponding boundary matrix inside the SparseBoundaryMatrix structure.

Critically, this method sorts simplices according to the total order specified by simplex_key:

Filtration value

Dimension

Lexical order of the sorted vertices

This defines a total order, as the lexical order ensures that two simplices of the same dimension can always be sorted (they necessarily differ by at least one vertex).

The boundary matrix can then be reduced in place using the:

SparseBoundaryMatrix.gaussian_elimination()


method (explained in more detail in Section 2 â€” Complexity Analysis).

Finally, barcodes can be inferred through the:

SparseBoundaryMatrix.get_barcode()


method, which stores and prints barcodes based on the reduced matrix.
If the matrix is not reduced yet, it first computes the reduction, and then computes the barcodes.

SparseBoundaryMatrix also provides auxiliary methods, especially:

SparseBoundaryMatrix.low()


which computes the lowest non-zero coefficient of a given column in the matrix.

Test and Plot Functions

The file test_plots.py allows testing our code on several topological structures (questions 5â€“6).
It makes use of data files in the data/ repository, especially the filtration files generated by the functions in filtration_generation.py.

filtration_generation.py

This module computes the following filtrations:

Sphere 
ğ‘†
ğ‘‘
S
d

Uses the boundary complex of the 
(
ğ‘‘
+
1
)
(d+1)-simplex: emits 
ğ‘‘
+
2
d+2 vertices at 
ğ‘¡
=
1
t=1,
then all faces of size 
2
,
â€¦
,
(
ğ‘‘
+
1
)
2,â€¦,(d+1) with strictly increasing timestamps, omitting the full 
(
ğ‘‘
+
1
)
(d+1)-cell.
Face-first order holds by construction; orientation is irrelevant over 
ğ‘
2
Z
2
	â€‹

.

Ball 
ğµ
ğ‘‘
B
d

Takes the full 
ğ‘‘
d-simplex: vertices at 
ğ‘¡
=
1
t=1, then every face up to dimension 
ğ‘‘
d, including the 
ğ‘‘
d-cell.
The complex is contractible, so only 
ğ»
0
H
0
	â€‹

 persists â€” useful as a sanity check for the 
âˆ‚
âˆ‚-reduction pipeline.

MÃ¶bius Band

Starts from a 
2
Ã—
3
2Ã—3 strip (6 vertices), adds horizontal and vertical edges plus a single â€œtwistâ€ bridge and minimal diagonals,
then fills with 2-simplices so that the edge combinatorics encode the half-twist.
Over 
ğ‘
2
Z
2
	â€‹

, this yields a single 
ğ»
1
H
1
	â€‹

 generator.

Torus 
ğ‘‡
2
T
2

Builds a 
3
Ã—
3
3Ã—3 periodic grid: adds wrap-around horizontal and vertical edges, triangulates each square (diagonals),
then inserts 2-simplices.
Periodic identifications along both axes produce two independent 
ğ»
1
H
1
	â€‹

 generators and one 
ğ»
2
H
2
	â€‹

 class.

Klein Bottle

Uses a 
3
Ã—
3
3Ã—3 grid with periodicity in one direction and a twisted identification in the other.
Across the twisted boundary, vertices are reindexed by reflection before adding edges and triangles.
With 
ğ‘
2
Z
2
	â€‹

 coefficients this yields two 
ğ»
1
H
1
	â€‹

 generators and one top class.

Projective Plane 
ğ‘…
ğ‘ƒ
2
RP
2

â€œStar + pentagonâ€ scheme: one center joined to a 5-cycle, plus selected chords to implement antipodal pairing,
then 10 triangles to close the complex.
The filtration respects face-first order and reproduces:

ğ›½
0
=
1
,
ğ›½
1
=
1
,
ğ›½
2
=
1
Î²
0
	â€‹

=1,Î²
1
	â€‹

=1,Î²
2
	â€‹

=1

over 
ğ‘
2
Z
2
	â€‹

.

Performance Evaluation

evaluate_perf.py computes the runtime of the algorithms in the SparseBoundaryMatrix class across several datasets.
Its plotting option provides a graphical representation of computation time as a function of the number of simplices (see Figure 2).

Examples

A simple example demonstrating how to use the main functions is provided in the example.py file,
which applies the algorithms to the simple filtration example from TD4
