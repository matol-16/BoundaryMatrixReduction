# BoundaryMatrixReduction

This repo is dedicated to a projet for the module *Topological Data Analysis* taught by Steve Oudot at **Ecole Polytechnique**.

## Code Organization

### Two main classes

Our code is organized around two core classes, each stored in a Python file of the same name:

- **`Simplex`**  
  Stores vertices, dimension, and filtration value for each simplex in a set.  
  Vertices are stored as a `frozenset` to allow indexing of sub-simplices in a dictionary.

- **`SparseBoundaryMatrix`**  
  The central class, representing the boundary matrix as a dictionary of column–row sets, optimized for the reduction algorithm.

After initialization, an instance of `SparseBoundaryMatrix` can be linked to a filtration using the method **`from_simplices`**, which constructs the corresponding boundary matrix.  
This method sorts simplices according to the total order defined by **`simplex_key`**:
1. Filtration value  
2. Dimension  
3. Lexical order of sorted vertices  

This ensures a *total order*, since simplices of equal dimension always differ by at least one vertex.

The matrix can then be reduced in place using the **`gaussian_elimination`** method (see Section 2, *Complexity Analysis*).

Finally, barcodes can be computed through **`get_barcode`**, which either uses the existing reduced matrix or performs reduction automatically before computing and displaying barcodes.

`SparseBoundaryMatrix` also provides auxiliary methods, notably **`low`**, which returns the lowest non-zero coefficient of a given column.

---

### Test and plot functions

The file **`test_plots.py`** tests the implementation on several topological structures (questions 5–6).  
It relies on data files in the `data/` directory, particularly the filtration files generated by **`filtration_generation.py`**.

**`filtration_generation.py`** computes the following filtrations:

- **Sphere \( S^d \)**  
  Uses the boundary complex of the \((d+1)\)-simplex: emits \(d+2\) vertices at \(t=1\), then adds faces of size \(2, \ldots, d+1\) with increasing timestamps, omitting the full \((d+1)\)-cell.  
  Face-first order holds by construction; orientation is irrelevant over \(\mathbb{Z}_2\).

- **Ball \( B^d \)**  
  Takes the full \(d\)-simplex: vertices at \(t=1\), then all faces up to dimension \(d\), including the \(d\)-cell.  
  The complex is contractible, so only \(H_0\) persists (useful as a sanity check for the boundary reduction pipeline).

- **Möbius band**  
  Starts from a \(2\times3\) strip (6 vertices), adds horizontal and vertical edges, a single “twist” bridge, and minimal diagonals, then fills with 2-simplices to encode the half-twist.  
  Over \(\mathbb{Z}_2\) this yields a single \(H_1\) generator.

- **Torus \( T^2 \)**  
  Builds a \(3\times3\) periodic grid: adds wrap-around edges and triangulates each square with diagonals, then inserts 2-simplices.  
  Periodic identifications along both axes produce two independent \(H_1\) generators and one \(H_2\) class.

- **Klein bottle**  
  Uses a \(3\times3\) grid with periodicity in one direction and a twisted identification in the other (via vertex reflection).  
  With \(\mathbb{Z}_2\) coefficients, this yields two \(H_1\) generators and a top class.

- **Projective plane \( \mathbb{RP}^2 \)**  
  “Star + pentagon” scheme: one central vertex joined to a 5-cycle, plus selected chords for antipodal pairing, and 10 triangles to close the complex.  
  The filtration respects face-first order and reproduces \(\beta_0 = 1\), \(\beta_1 = 1\), \(\beta_2 = 1\) over \(\mathbb{Z}_2\).

---

### Performance evaluation

**`evaluate_perf.py`** computes the execution time of the algorithms in the `SparseBoundaryMatrix` class across several datasets.  
Its plotting option produces graphs showing computation time as a function of the number of simplices (see Figure 2).

---

### Examples

A minimal example of usage is provided in **`example.py`**, which applies the algorithms to the simple filtration example from TD4.
